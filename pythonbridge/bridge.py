import sys
import json
from typing import Optional, Any

from pydantic import BaseModel

from pythonbridge.main import main

# This receives all the messages from Elixir.
# It's going to import all the other Python modules (LangChain, ChromaDB, etc)
# When we're going for scaling we are going to use elixir workers
# All send request to the same bridge but the bridge.py routes the right function based on the type field. No multiple Python processes.


class BridgeResponse(BaseModel):
    """
    Represents the responses that is generated by Python processes and sent back to Elixir
    """

    status: str
    response: Optional[Any] = None  # can be any json type
    error: Optional[str] = None


def handle_msg(msg: dict) -> BridgeResponse:
    """Route messages based on type field.

    Args:
        msg (dict): Message received from Elixir
            - "type": Message type for routing
            - "_id": Request correlation ID (added automatically by Elixir)

    Returns:
        dict: A response dictionary
    """
    type = msg.get("type")

    if type == "hello":
        count = msg.get("count", 0)
        return BridgeResponse(status="ok", response=f"hello from python {count}")

    elif type == "main":
        payload = msg.get("payload")
        if not payload:
            return BridgeResponse(status="error", error="Missing payload")
        try:
            reviews = main(payload)
            return BridgeResponse(status="ok", response=reviews)
        except Exception as e:
            return BridgeResponse(status="error", error=str(e))

    else:
        return BridgeResponse(status="error", error=f"Unknown message type: {type}")


# Do not run this file directly, it's only used by Elixir
if __name__ == "__main__":
    for line in sys.stdin:
        msg = json.loads(line)
        response = handle_msg(msg).model_dump()
        response["_id"] = msg.get("_id")
        print(json.dumps(response))
        sys.stdout.flush()
